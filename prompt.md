# 통신 구조

- User App(Admin, Staff) ↔ Main server : Fast API
    - 관리자 앱과 직원(사용자) 앱과의 인터랙션
- Main server ↔ AI server : gRPC
    - LLM 또는 vision 모델 추론결과값을 Main server로 스트리밍 또는 AI 서버로 요청/응답
- Main Server ↔ Robots : ros_bridge(Main server: Python, Robots: ROS2)
    - Main server가 robots을 관리 및 제어
    - Robot의 상태를 전송
- Robots → AI server : UDP
    - 비전 추론을 위한 이미지 전송
- DB : MySQL (Main server안에 존재)

# 시나리오

## 목적지 이동 시나리오

- 메인서버가 최적의 Global 경로를 생성
    - 고려사항 : 제한구역 제외 , 거리, 코너 수, 혼잡도(로봇) 등
- 메인서버가 해당 로봇에게 waypoints 형태로 최적의 Global 경로를 제공
- 로봇은 글로벌하게는 그 경로를 따라감
- 로봇은 로컬하게는 로봇안에 탑재된 로컬 알고리즘을 적용하여 움직임
    - 라이다, SLAM → Cost Map
    - 추론을 통한 장애물 종류에 따른
- 로봇은 이동완료후 메인서버에게 이동완료를 보내고 대기

## 로컬 이동 시나리오

## 간식 시나리오

1. 한 Staff app 에서 메인서버로 자연어 프롬프트로 명령을 보냄 (간식, 어떤 간식)
2. 메인서버는 AI 서버에게 자연어 프롬프트를 넘겨준 후 LLM 모델을 통해 구조화된 언어를 받음
3. 메인서버는 그 받은 정보를 바탕으로 해당 직원 앱에 푸시알람, 사용자 확인 받은 후 최적의 로봇을 할당
4. 그에 맞는 최적의 경로(waypoints)를 생성하여 그 로봇에게 간식창고 입구로 이동명령을 내림
5. 해당 로봇은 간식 창고 입구로 이동 후 대기
6. 간식창고 안에 어떤 로봇도 없을경우 해당 로봇에게 해당 간식 앞으로 이동명령
7. 로봇이 해당 간식 앞에 도착시 메인서버는 AI서버에 해당 로봇의 영상 추론 결과 요청
8. 추론 결과와 요청 간식과 비교해서 일치시 메인서버가 로봇에게 로딩작업 명령 (3초 대기로 대체)
9. 로딩 완료시 메인서버가 로봇에게 주문 사용자 사무실로 이동명령
10. 로봇이 도착 후 메인서버에게 알려주고 메인서버는 해당 사용자 앱에 푸시알람
11. 사용자가 확인버튼을 누르면 메인서버를 거쳐 해당 로봇에게 복귀 명령
12. 해당 로봇이 도착하면 메인서버에게 알림 (임무 완료)

## P2P 배달 시나리오

1. 한 발송자 staff app에서 메인서버에게 자연어 프롬프트로 전달 (배달, 어디로, 수신자)
2. 메인서버는 그 내용을 AI서버에게 전달 하고 LLM모델을 통해 구조화된 언어를 받음
3. 메인서버는 그 받은 정보를 바탕으로 해당직원 앱에 푸시 알람 및 확인 요청
4. 확인을 받으면 메인서버는 그것에 맞는 최적의 로봇을 할당 후 사용자 앱에 푸시 알람
5. 그 해당 로봇에게 발송자 사무실로 이동 명령
6. 로봇이 사무실 도착후 메인서버에게 알리고 메인서버는 발송자 앱에 물건 로딩 요청
7. 발송자가 로딩 완료 버튼을 누르면 메인서버가 로봇에게 배달 위치로 이동 명령
8. 메인서버는 수신자 앱에 푸시알람 (배달중)
9. 배달 위치 도착시 수신자와 발송자에게 앱 푸시 알람, 수신자에게 배송수령완료 요청
10. 수신자가 배송수령완료 확인시 메인서버는 로봇에게 복귀명령 요청
11. 메인서버는 발송자에게 배송완료 푸시알람
12. 로봇 복귀 완료시 메인서버에게 알림 (임무완료)

## 직원 인증 시나리오

## 가이딩 시나리오

1. 로봇은 QR코드에 대한 정보를 메인서버로 보냄
2. 메인서버는 QR 코드를 분석해 인증된 게스트인지 확인
3. 확인시 메인서버는 해당 사용자 앱에 푸시알람
4. 메인서버는 특정 회의실로 가이딩 이동 명령
5. 로봇이 게스트를 어떻게 알건데???????????????????????????????????//
6. 로봇이 게스트와 특정거리 이하를 유지하면서 가이드
7. 게스트를 놓칠시 잠시 대기 (부저?)
8. 목표 위치에 도착시 메인서버에게 알림
9. 메인서버는 로봇에게 LCD에 글자 5초간 디스플레이 명령
10. 5초 후 메인서버가 로봇에게 복귀 명령
11. 복귀완료시 메인서버에게 알림 (임무완료)

## 금지 구역 설정 시나리오

1. Admin App을 통해 맵에 금지구역 설정후 메인서버에게 정보 보냄
2. 메인 서버가 가진 맵에 금지구역을 저장
3. 메인서버가 로봇에게 이동명령 할때 waypoints 생성시 금지구역 안에 있는 waypoint는 배제 하고 global path 설정

## **방문 예약 및 QR 발급 시나리오**

1. Staff App → 메인 서버: 직원이 방문객 정보(이름, 방문 목적, 시간)를 입력하여 예약 요청을 보냄.
2. 메인 서버 → Admin App: 관리자 앱으로 예약 승인 요청 푸시 알림을 전송함.
3. Admin App → 메인 서버: 관리자가 예약 내용을 확인 후 '승인' 결정을 서버에 전달함.
4. 메인 서버: 승인 즉시 고유 식별값(Unique Token)을 생성하고 DB에 저장(상태: 미사용)함.
5. 메인 서버 → Staff App: 예약이 최종 완료되었음 메세지와 함께 서버는 해당 토큰이 담긴 QR 코드 이미지를 생성하여 예약을 신청한 담당 직원에게 전송함

## 로비 도착 및 QR 인증

1. **방문객 → 로봇 (QR 제시)**
    - 로비에 도착한 방문객이 스태프로부터 전달받은 QR 코드를 안내 로봇의 카메라에 제시함.
2. **로봇 → 메인 서버 (데이터 전송)**
    - 로봇은 스캔된 QR 데이터(문자열/토큰)를 즉시 추출하여 메인 서버에 인증 요청을 보냄.
3. **메인 서버 ↔ DB (유효성 검증)**
    - 메인 서버는 수신된 QR 값이 DB에 존재하는지 조회하고, 예약 시간 준수 여부 및 미사용 상태를 대조하여 1차 검증함.
4. **메인 서버 → AI 서버 (추론 요청)**
    - QR 인증이 성공하면, 메인 서버는 로봇의 카메라 실시간 영상을 ****AI 서버로 전달하며 '사람 인식 및 상태 추론'을 요청함.
5. **AI 서버 → 메인 서버 (결과 반환)**
    - AI 서버는 영상 속 인물이 실제 방문객임을 파악한 후, "인증된 방문객 1명 확인"과 같은 구조화된 언어 데이터를 메인 서버에 반환함.
6. **메인 서버 (인증 완료)**
    - AI 서버의 추론 결과까지 일치할 경우, 최종적으로 해당 방문자의 입장을 승인하고 다음 안내 단계(로봇 할당 등)를 준비함.


# Main-AI 상세 인터페이스
| Action | RPC Name | Request (Main → AI) | Response (AI → Main) |
| --- | --- | --- | --- |
| AI 서버 추론 제어 명령 | `UpdateInferenceState` |   • `robot_id` 
  • `model_type` (string): [FACE, Obstacle| SNACK]
  • `is_active` (bool): False면 추론 중지 |   • `success` (bool)
  • `message` (string) (error msg) |
| 자연어 프롬프트 해석 요청 | `AnalyzePrompt` |   • `user_id` (int) 
  • `prompt` (string): "물 한 잔 갖다 줘" |   •  `user_id` (string)
  •  `intent` (string): "SNACK_DELIVERY | DELIVERY | IOT"
  •  `params` (JSON string): `{"target":"water"}` |
| 직원 식별 스트리밍 | `StreamFaceAuth` |   •  `robot_id` (string) | **(Stream)
  •** `frame_id`(string)
  • `status` (enum):
[ DETECTED | MATCHED |  UNKNOWN]
  • `staff_id` (string)
  • `confidence` (float)
 |
| 간식 확인 요청 | `StreamObjectCheck` |   •  `robot_id` (string)
  •  `target_class` (string): "snack_A" |   •  `is_match` (bool)
  • `detected_class` (string) |
| 장애물 판별 스트리밍 | `StreamObjectScan` | • `robot_id` (string)
 | **(Stream)**
• `frame_id`
• `is_found`
• `bbox_info` |